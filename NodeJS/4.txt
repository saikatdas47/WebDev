//HTTP Methods
// HTTP methods are used to indicate the desired action to be performed on a resource in a web server.
// The most common HTTP methods are:

// 1. GET: Requests data from a specified resource. It should only retrieve data and have no other effect.
// 2. POST: Submits data to be processed to a specified resource, often causing a change in state or side effects on the server.
// 3. PUT: Replaces all current representations of the target resource with the uploaded content.
// 4. PATCH: Partially modifies a resource. Only the specified changes are applied.
// 5. DELETE: Removes the specified resource from the server.
// 6. HEAD: Same as GET, but it transfers the status line and header section only, without the response body.
// 7. OPTIONS: Describes the communication options for the target resource.
// 8. TRACE: Performs a message loop-back test along the path to the target resource.
// 9. CONNECT: Establishes a tunnel to the server identified by the target resource.

// Each method serves a specific purpose and is used according to the requirements of the application.






/*
Express Framework:  % npm i express

Express is a minimal and flexible Node.js web application framework that provides a robust set of features for building web and mobile applications.

Why Express came into existence:
- Node.js provides basic HTTP server capabilities, but building complex web applications with just Node.js can be repetitive and time-consuming.
- Express was created to simplify the process of handling routes, requests, responses, middleware, and more.

Why we use Express:
- Simplifies routing and handling HTTP methods.
- Makes middleware integration easy for tasks like authentication, logging, and error handling.
- Provides utilities for serving static files, parsing request bodies, and managing cookies.
- Enables rapid development of RESTful APIs and web applications.

Problems without Express:
- You would need to manually handle routing, request parsing, and response formatting.
- Middleware management would be complex and less organized.
- Code would be more verbose and harder to maintain.
- Common tasks like error handling, serving static files, and parsing form data would require extra code.

In summary, Express streamlines web development in Node.js, making code cleaner, more maintainable, and easier to scale.

https://youtu.be/N2-FyBBxOZA?si=dNIo0WUdQQBd_ewP
*/





/*
Package Versioning in Node.js (npm):

When you install packages using npm, you often see version numbers like "express": "^4.18.2" in package.json. These numbers and symbols control which versions of a package your project will use.

Semantic Versioning (semver):
- Format: MAJOR.MINOR.PATCH (e.g., 2.5.1)
    - MAJOR: Breaking changes
    - MINOR: New features, backward-compatible
    - PATCH: Bug fixes, backward-compatible

Symbols in package.json:
- ^ (Caret): Allows updates that do not change the leftmost non-zero digit. For example, "^1.2.3" matches "1.x.x" but not "2.0.0".
- ~ (Tilde): Allows updates to the most recent PATCH version. For example, "~1.2.3" matches "1.2.x" but not "1.3.0".
- No symbol: Installs the exact version specified.
- * (Asterisk): Matches any version.

Examples:
- "^2.3.4" → Accepts "2.3.4", "2.4.0", "2.9.9", but not "3.0.0"
- "~2.3.4" → Accepts "2.3.4", "2.3.5", but not "2.4.0"
- "2.3.4" → Only installs "2.3.4"

Why versioning matters:
- Ensures compatibility and stability.
- Allows you to control when to accept new features or breaking changes.
- Helps avoid unexpected bugs from automatic updates.

In summary, use "^" for safe feature updates, "~" for only bug fixes, and exact versions for maximum stability.
*/ 





/*
RESTful API:

A RESTful API (Representational State Transfer) is an architectural style for designing networked applications. It uses HTTP methods to perform operations on resources, which are identified by URLs.

Key principles:
- Stateless: Each request from a client contains all the information needed to process it.
- Resources: Everything is a resource, accessible via a unique URL.
- HTTP Methods: Uses standard HTTP methods (GET, POST, PUT, PATCH, DELETE) to perform CRUD operations.
- Representation: Resources can be represented in different formats, commonly JSON or XML.

Example RESTful routes for a "users" resource:
- GET /users         → Retrieve all users
- GET /users/:id     → Retrieve a specific user
- POST /users        → Create a new user
- PUT /users/:id     → Replace a user
- PATCH /users/:id   → Update part of a user
- DELETE /users/:id  → Delete a user

RESTful APIs are widely used for building scalable and maintainable web services.

 * Sends data from the server to the client in < HTML document > format.
 * This approach is used when the server needs to deliver a fully-rendered web page or a fragment of HTML
 * that the client can directly display in the browser. Sending data as HTML is common in traditional web applications,
 * server-side rendering frameworks, or 
 
 when the client expects ready-to-render markup instead of raw data (like JSON or XML).
 * This reduces the need for client-side rendering logic and allows for faster initial page loads and improved SEO,
 * as the content is immediately available to the browser and search engines.  react, flutter etc
 
 https://youtu.be/cJAyEOZQUQY?si=9m7QxdEx-Yjr0lWe

 */
restApiProject




Express Middleware

Middleware in Express is a function that has access to the request object (req), the response object (res), and the next middleware function in the application’s request-response cycle. Middleware functions can execute code, modify the request and response objects, end the request-response cycle, or call the next middleware in the stack.

Why we need middleware:
- To perform common tasks such as logging, authentication, error handling, parsing request bodies, and serving static files.
- To keep code modular and reusable by separating concerns.
- To process requests before they reach the route handlers or after the response is generated.

Where we use middleware:
- Globally for all routes (e.g., app.use()).
- For specific routes (e.g., app.use('/api', middlewareFunction)).
- As built-in middleware (like express.json(), express.static()) or custom middleware for application-specific logic.

Middleware is essential for building scalable, maintainable, and secure Express applications.

/*
HTTP Headers:

HTTP headers are key-value pairs sent between the client and server with every HTTP request and response. They provide essential metadata about the request or response, such as content type, authentication, caching, and more.

Server-side headers:
- Sent by the server in the HTTP response.
- Examples:
    - Content-Type: Specifies the media type (e.g., application/json, text/html)
    - Set-Cookie: Sets cookies in the client browser
    - Cache-Control: Controls caching behavior
    - Content-Length: Size of the response body
    - Server: Information about the server software

Client-side headers:
- Sent by the client (browser or API client) in the HTTP request.
- Examples:
    - Host: The domain name of the server
    - User-Agent: Information about the client software
    - Accept: Media types the client can process
    - Authorization: Credentials for authentication
    - Cookie: Cookies previously set by the server

Custom headers:
- You can define your own headers for application-specific needs.
- Syntax: Custom headers are usually prefixed with "X-" (e.g., X-Auth-Token, X-Request-ID).
- Example:
    X-Custom-Header: myValue

Why use custom headers:
- To send additional information not covered by standard headers (e.g., tracking IDs, custom authentication tokens, feature flags).
- For internal communication between services or for debugging.

Why the "X-" prefix:
- Historically, "X-" was used to indicate non-standard, experimental, or custom headers to avoid conflicts with future standard headers.
- As of RFC 6648, the use of "X-" is discouraged, but it is still widely used for legacy and clarity reasons.

In summary, HTTP headers are crucial for controlling and describing HTTP communication, and custom headers allow you to extend this functionality for your application's needs.




/*
HTTP Status Codes:

HTTP status codes are standardized codes returned by servers to indicate the result of a client's request. They help clients understand whether a request was successful, failed, or requires further action.

Categories:
- 1xx (Informational): Request received, continuing process.
- 2xx (Success): The request was successfully received, understood, and accepted.
    - 200 OK: The request succeeded.
    - 201 Created: The request succeeded and a new resource was created.
    - 204 No Content: The request succeeded, but there is no content to send.
- 3xx (Redirection): Further action needs to be taken to complete the request.
    - 301 Moved Permanently: The resource has been moved to a new URL.
    - 302 Found: The resource is temporarily at a different URL.
- 4xx (Client Error): The request contains bad syntax or cannot be fulfilled.
    - 400 Bad Request: The server could not understand the request.
    - 401 Unauthorized: Authentication is required.
    - 403 Forbidden: The server understood the request but refuses to authorize it.
    - 404 Not Found: The requested resource could not be found.
- 5xx (Server Error): The server failed to fulfill a valid request.
    - 500 Internal Server Error: A generic server error occurred.
    - 502 Bad Gateway: The server received an invalid response from an upstream server.
    - 503 Service Unavailable: The server is currently unable to handle the request.

Why status codes matter:
- They provide clear feedback to clients about the outcome of their requests.
- Help with debugging and error handling.
- Enable clients to take appropriate actions based on the response.

In summary, HTTP status codes are essential for effective communication between clients and servers in web applications.